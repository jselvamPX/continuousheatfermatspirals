#include <pybind11/pybind11.h>
#include <pybind11/eigen.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>

#include "Spirals.h"
#include "SpiralDt.h"

#include <vector> // Required for std::vector
#include <iostream> // Required for std::cout

namespace py = pybind11;

// Function to convert spiral points to a NumPy array
py::array_t<double> spiral_to_numpy(const IterLine::VHandle& spiral_start, IterLine& iter_line) {
    // Define the shape for an empty 2D array (0 rows, 3 columns)
    py::array::ShapeContainer empty_shape({0L, 3L}); // Use long literal L for clarity

    // Count the number of points in the spiral starting from spiral_start
    int num_points = 0;
    IterLine::VHandle vh = spiral_start;
    int max_count = iter_line.get_num_points() * 2;
    int count = 0;

    if (!vh.is_valid()) {
        return py::array_t<double>(empty_shape);
    }

    do {
        num_points++;
        vh = iter_line.next(vh);
        if (count++ > max_count) {
            std::cerr << "Warning: Exceeded max count in spiral_to_numpy. Possible loop in IterLine data." << std::endl;
             return py::array_t<double>(empty_shape);
        }
    } while (vh.is_valid() && vh.i != spiral_start.i);


    if (num_points == 0) {
         return py::array_t<double>(empty_shape);
    }

    // Create a NumPy array to hold the spiral points
    // *** Use explicit ShapeContainer ***
    py::array::ShapeContainer result_shape({(py::ssize_t)num_points, 3L});
    py::array_t<double> result(result_shape);
    py::buffer_info buf = result.request();
    double* ptr = static_cast<double*>(buf.ptr);

    // Fill the array with spiral points
    vh = spiral_start;
    count = 0;
    int i = 0;
    do {
        if (i >= num_points) {
             std::cerr << "Error: Index out of bounds in spiral_to_numpy fill loop." << std::endl;
             break;
        }
        const Eigen::RowVector3d& p = iter_line.p(vh);
        ptr[i * 3 + 0] = p[0];
        ptr[i * 3 + 1] = p[1];
        ptr[i * 3 + 2] = p[2];
        i++;
        vh = iter_line.next(vh);
         if (count++ > max_count) break;
    } while (vh.is_valid() && vh.i != spiral_start.i);

    return result;
}

// Function to extract ALL points generated by isoline_cut
py::array_t<double> all_isoline_points_to_numpy(IterLine& iter_line) {
    int num_points = iter_line.get_num_points();
    py::array::ShapeContainer empty_shape({0L, 3L});

    if (num_points <= 0) {
        return py::array_t<double>(empty_shape);
    }

    // Create array with shape (num_points, 3)
    // *** Use explicit ShapeContainer ***
    py::array::ShapeContainer result_shape({(py::ssize_t)num_points, 3L});
    py::array_t<double> result(result_shape);
    py::buffer_info buf = result.request();
    double* ptr = static_cast<double*>(buf.ptr);

    const auto& points = iter_line.get_points();
    if (points.size() != num_points) {
         std::cerr << "Error: Mismatch between get_num_points() and points vector size." << std::endl;
         return py::array_t<double>(empty_shape);
    }

    for (int i = 0; i < num_points; ++i) {
        ptr[i * 3 + 0] = points[i][0];
        ptr[i * 3 + 1] = points[i][1];
        ptr[i * 3 + 2] = points[i][2];
    }

    return result;
}


// Main function to generate a spiral from vertices and faces
py::array_t<double> generate_spiral(
    py::array_t<double> vertices_array,
    py::array_t<int> faces_array,
    int source_idx = 0,
    double diffusion_time = 0.1,
    int num_isolines = 200
) {
    py::array::ShapeContainer empty_shape({0L, 3L});

    py::buffer_info vertices_buf = vertices_array.request();
    py::buffer_info faces_buf = faces_array.request();

    if (vertices_buf.ndim != 2 || vertices_buf.shape[1] != 3) {
        throw std::runtime_error("Vertices must be an Nx3 array");
    }
    if (faces_buf.ndim != 2 || faces_buf.shape[1] != 3) {
        throw std::runtime_error("Faces must be an Mx3 array");
    }

    int num_vertices = vertices_buf.shape[0];
    int num_faces = faces_buf.shape[0];

    vertices_array = py::array::ensure(vertices_array, py::array::c_style | py::array::forcecast);
    faces_array = py::array::ensure(faces_array, py::array::c_style | py::array::forcecast);
    vertices_buf = vertices_array.request();
    faces_buf = faces_array.request();

     if (vertices_buf.format != py::format_descriptor<double>::format() ||
         faces_buf.format != py::format_descriptor<int>::format()) {
         throw std::runtime_error("Input arrays have incorrect data types (expected double for vertices, int for faces)");
     }


    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> V_map(
        static_cast<double*>(vertices_buf.ptr), num_vertices, 3);
    Eigen::Map<Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> F_map(
        static_cast<int*>(faces_buf.ptr), num_faces, 3);

    Eigen::MatrixXd V = V_map;
    Eigen::MatrixXi F = F_map;

    TriMesh mesh;
    std::vector<TriMesh::VertexHandle> vhandles;
    vhandles.reserve(V.rows());
    for (int i = 0; i < V.rows(); i++) {
        vhandles.push_back(mesh.add_vertex(TriMesh::Point(V(i, 0), V(i, 1), V(i, 2))));
    }

    std::vector<TriMesh::VertexHandle> face_vhandles(3);
    for (int i = 0; i < F.rows(); i++) {
         if (F(i, 0) < 0 || F(i, 0) >= num_vertices ||
             F(i, 1) < 0 || F(i, 1) >= num_vertices ||
             F(i, 2) < 0 || F(i, 2) >= num_vertices) {
             throw std::runtime_error("Face index out of bounds for vertices array.");
         }
        face_vhandles[0] = vhandles[F(i, 0)];
        face_vhandles[1] = vhandles[F(i, 1)];
        face_vhandles[2] = vhandles[F(i, 2)];
        mesh.add_face(face_vhandles);
    }

    std::cout << "Computing distance field..." << std::endl;
    Eigen::VectorXd distance_field = distance_field_from_heat(V, F, source_idx, diffusion_time);
    std::cout << "Distance field computed." << std::endl;

    IterLine iter_line;
    std::cout << "Generating isolines (isoline_cut)..." << std::endl;
    isoline_cut(mesh, iter_line, distance_field, num_isolines);
    std::cout << "Isolines generated. Number of points: " << iter_line.get_num_points() << std::endl;

    std::cout << "Extracting regions..." << std::endl;
    auto regions = iter_line.region_extract();
     std::cout << "Regions extracted. Count: " << regions.size() << std::endl;
     if (regions.empty()) {
         std::cerr << "Warning: No regions extracted from isolines. Cannot make spiral." << std::endl;
         return py::array_t<double>(empty_shape);
     }

    std::cout << "Making Fermat spiral..." << std::endl;
    auto [fs_start, fs_end] = iter_line.make_fermat_spiral(regions);
    std::cout << "Fermat spiral constructed. Start handle: " << fs_start.i << ", End handle: " << fs_end.i << std::endl;

    std::cout << "Converting spiral to NumPy array..." << std::endl;
    py::array_t<double> result = spiral_to_numpy(fs_start, iter_line);
    std::cout << "Conversion complete. Result shape: (" << result.shape(0) << ", " << result.shape(1) << ")" << std::endl;

    return result;
}

// Helper function to compute the distance field
py::array_t<double> compute_distance_field(
    py::array_t<double> vertices_array,
    py::array_t<int> faces_array,
    int source_idx = 0,
    double diffusion_time = 0.1
) {
    py::buffer_info vertices_buf = vertices_array.request();
    py::buffer_info faces_buf = faces_array.request();

    if (vertices_buf.ndim != 2 || vertices_buf.shape[1] != 3) {
        throw std::runtime_error("Vertices must be an Nx3 array");
    }
    if (faces_buf.ndim != 2 || faces_buf.shape[1] != 3) {
        throw std::runtime_error("Faces must be an Mx3 array");
    }

    int num_vertices = vertices_buf.shape[0];
    int num_faces = faces_buf.shape[0];

    vertices_array = py::array::ensure(vertices_array, py::array::c_style | py::array::forcecast);
    faces_array = py::array::ensure(faces_array, py::array::c_style | py::array::forcecast);
    vertices_buf = vertices_array.request();
    faces_buf = faces_array.request();

     if (vertices_buf.format != py::format_descriptor<double>::format() ||
         faces_buf.format != py::format_descriptor<int>::format()) {
         throw std::runtime_error("Input arrays have incorrect data types (expected double for vertices, int for faces)");
     }


    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> V_map(
        static_cast<double*>(vertices_buf.ptr), num_vertices, 3);
    Eigen::Map<Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> F_map(
        static_cast<int*>(faces_buf.ptr), num_faces, 3);

    Eigen::MatrixXd V = V_map;
    Eigen::MatrixXi F = F_map;

    Eigen::VectorXd distance_field = distance_field_from_heat(V, F, source_idx, diffusion_time);

    // Create a NumPy array of the correct size first.
    py::array_t<double> result({(py::ssize_t)distance_field.size()});
    py::buffer_info result_buf = result.request();
    Eigen::Map<Eigen::VectorXd> result_map(static_cast<double*>(result_buf.ptr), distance_field.size());
    result_map = distance_field;

    return result;
}

// Helper function to generate isolines from a distance field
// *** MODIFIED TO SKIP SPIRAL CONNECTION ***
py::array_t<double> generate_isolines(
    py::array_t<double> vertices_array,
    py::array_t<int> faces_array,
    py::array_t<double> distance_field_array,
    int num_isolines = 200
) {
    py::buffer_info vertices_buf = vertices_array.request();
    py::buffer_info faces_buf = faces_array.request();
    py::buffer_info distance_field_buf = distance_field_array.request();

    if (vertices_buf.ndim != 2 || vertices_buf.shape[1] != 3) throw std::runtime_error("Vertices must be an Nx3 array");
    if (faces_buf.ndim != 2 || faces_buf.shape[1] != 3) throw std::runtime_error("Faces must be an Mx3 array");
    if (distance_field_buf.ndim != 1) throw std::runtime_error("Distance field must be a 1D array");
    if (distance_field_buf.shape[0] != vertices_buf.shape[0]) throw std::runtime_error("Distance field size must match number of vertices");


    int num_vertices = vertices_buf.shape[0];
    int num_faces = faces_buf.shape[0];

    vertices_array = py::array::ensure(vertices_array, py::array::c_style | py::array::forcecast);
    faces_array = py::array::ensure(faces_array, py::array::c_style | py::array::forcecast);
    distance_field_array = py::array::ensure(distance_field_array, py::array::c_style | py::array::forcecast);

    vertices_buf = vertices_array.request();
    faces_buf = faces_array.request();
    distance_field_buf = distance_field_array.request();

     if (vertices_buf.format != py::format_descriptor<double>::format() ||
         faces_buf.format != py::format_descriptor<int>::format() ||
         distance_field_buf.format != py::format_descriptor<double>::format() ) {
         throw std::runtime_error("Input arrays have incorrect data types (expected double, int, double)");
     }


    Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> V_map(
        static_cast<double*>(vertices_buf.ptr), num_vertices, 3);
    Eigen::Map<Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>> F_map(
        static_cast<int*>(faces_buf.ptr), num_faces, 3);
    Eigen::Map<Eigen::VectorXd> D_map(
        static_cast<double*>(distance_field_buf.ptr), num_vertices);

    Eigen::MatrixXd V = V_map;
    Eigen::MatrixXi F = F_map;
    Eigen::VectorXd D = D_map;

    TriMesh mesh;
    std::vector<TriMesh::VertexHandle> vhandles;
     vhandles.reserve(V.rows());
    for (int i = 0; i < V.rows(); i++) {
        vhandles.push_back(mesh.add_vertex(TriMesh::Point(V(i, 0), V(i, 1), V(i, 2))));
    }

    std::vector<TriMesh::VertexHandle> face_vhandles(3);
    for (int i = 0; i < F.rows(); i++) {
         if (F(i, 0) < 0 || F(i, 0) >= num_vertices ||
             F(i, 1) < 0 || F(i, 1) >= num_vertices ||
             F(i, 2) < 0 || F(i, 2) >= num_vertices) {
             throw std::runtime_error("Face index out of bounds for vertices array.");
         }
        face_vhandles[0] = vhandles[F(i, 0)];
        face_vhandles[1] = vhandles[F(i, 1)];
        face_vhandles[2] = vhandles[F(i, 2)];
        mesh.add_face(face_vhandles);
    }

    IterLine iter_line;
    std::cout << "Generating isolines (isoline_cut)..." << std::endl;
    isoline_cut(mesh, iter_line, D, num_isolines);
    int num_generated_points = iter_line.get_num_points();
    std::cout << "Isolines generated by isoline_cut. Total points: " << num_generated_points << std::endl;

    // --- MODIFICATION START ---
    // Skip the spiral connection part:
    // auto regions = iter_line.region_extract();
    // auto [fs_start, fs_end] = iter_line.make_fermat_spiral(regions);

    // Instead, directly extract all points generated by isoline_cut
    std::cout << "Skipping make_fermat_spiral. Extracting all generated points..." << std::endl;
    py::array_t<double> result = all_isoline_points_to_numpy(iter_line);
    std::cout << "Extraction complete. Result shape: (" << result.shape(0) << ", " << result.shape(1) << ")" << std::endl;
    // --- MODIFICATION END ---

    return result; // Return all points
}


PYBIND11_MODULE(_heat_fermat_3d_core, m) {
    m.doc() = "Python bindings for Fermat3D spiral generation";

    m.def("generate_spiral", &generate_spiral,
          py::arg("vertices"), py::arg("faces"),
          py::arg("source_idx") = 0, py::arg("diffusion_time") = 0.1, py::arg("num_isolines") = 200,
          "Generate a continuous spiral line from vertices and faces (computes distance field, isolines, and connects spiral)");

    m.def("compute_distance_field", &compute_distance_field,
          py::arg("vertices"), py::arg("faces"), py::arg("source_idx") = 0, py::arg("diffusion_time") = 0.1,
          "Compute a distance field from vertices and faces using the heat method");

    // Keep the modified generate_isolines function signature and docstring
    m.def("generate_isolines", &generate_isolines,
          py::arg("vertices"), py::arg("faces"), py::arg("distance_field"),
          py::arg("num_isolines") = 200,
          "Generate isolines from vertices, faces, and a distance field. ***MODIFIED: Returns all points from isoline_cut, does NOT connect them into a spiral.***");
}
